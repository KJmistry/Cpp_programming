# namespace in C++

Using namespace, you can define the space or context in which identifiers are defined i.e. variable, method, classes. In essence, a namespace defines a scope.

__Defining a Namespace:__

Syntax:

    namespace namespace_name
    {

    }

The __using__ directive avoides prepending of namespaces. (i.e. std::cout) This directive tells the compiler that the subsequent code is making use of names in the specified namespace.

- Multiple namespace blocks with the same name are allowed. The second namespace block is nothing but actually the continuation of the first namespace.
- Namespace declarations appear only at global scope.
- Namespace declarations can be nested within another namespace.
- Namespace declarations donâ€™t have access specifiers (Public or Private).
- No need to give a semicolon after the closing brace of the definition of namespace.
- We can split the definition of namespace over several units.
- Names introduced in a using directive are visible from the point the using directive occurs to the end of the scope in which the directive is found.
- Namespace provides the advantage of avoiding name collision.

Refer [Examole.](../namespace_example.cpp)

__unnamed namespace:__

- They are directly usable in the same program and are used for declaring unique identifiers.
- In unnamed namespaces, name of the namespace in not mentioned in the declaration of namespace.
- The name of the namespace is uniquely generated by the compiler.
- The unnamed namespaces you have created will only be accessible within the file you created it in.
- Unnamed namespaces are the replacement for the static declaration of variables.

Example:

```c++

// C++ program to demonstrate working of unnamed namespaces
#include <iostream>
using namespace std;

// unnamed namespace declaration
namespace
{
    int rel = 300;
}

int main()
{
    cout << rel << "\n"; // prints 300
    return 0;
}

```

__Inline namespace:__

An inline namespace is a namespace that uses the optional keyword inline in its original-namespace definition. This allows the identifiers of the nested inline namespace to behave as if they are the identifier of the parent/enclosing namespace.

syntax:

    inline namespace namespace_name;

Advantages of using inline namespaces:

- Avoid verbose: cout << ns1::ns2::ns3::var; --> cout << ns1::var;
- Support of Library: The inline namespace mechanism is intended to support library evolution by providing a mechanism that supports a form of versioning.__(?Doubt)__
